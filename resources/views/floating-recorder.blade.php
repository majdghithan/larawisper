<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <title>Larawisper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            background: transparent;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-app-region: drag;
        }

        .container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
        }

        .pill {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 12px 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3b30;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }

        .status-indicator.idle {
            background: #8e8e93;
            animation: none;
        }

        .status-indicator.processing {
            background: #ff9500;
            animation: pulse 0.8s ease-in-out infinite;
        }

        .waveform-container {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 24px;
        }

        .waveform-bar {
            width: 3px;
            background: linear-gradient(to top, #8b5cf6, #a78bfa);
            border-radius: 2px;
            transition: height 0.05s ease;
        }

        .text {
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }

        .text .shortcut {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 4px;
        }

        .hidden {
            display: none !important;
        }

        /* States */
        .state-idle .waveform-container { display: none; }
        .state-recording .idle-text { display: none; }
        .state-processing .waveform-container { display: none; }
        .state-processing .idle-text { display: none; }

        /* Hide entire container when idle */
        .state-idle .pill {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }

        .pill {
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .state-recording .pill,
        .state-processing .pill {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="pill" class="pill state-idle">
            <div id="status-indicator" class="status-indicator idle"></div>

            <!-- Waveform visualization -->
            <div id="waveform" class="waveform-container">
                <!-- Bars will be generated by JS -->
            </div>

            <!-- Text content -->
            <div class="text">
                <span id="idle-text" class="idle-text">
                    Press <span class="shortcut">{{ config('wisper.shortcut') }}</span> to record
                </span>
                <span id="recording-text" class="recording-text hidden">
                    Recording...
                </span>
                <span id="processing-text" class="processing-text hidden">
                    Processing...
                </span>
            </div>
        </div>
    </div>

    @vite(['resources/js/app.js'])
    <script>
        // Generate waveform bars
        const waveformContainer = document.getElementById('waveform');
        const NUM_BARS = 20;
        const bars = [];

        for (let i = 0; i < NUM_BARS; i++) {
            const bar = document.createElement('div');
            bar.className = 'waveform-bar';
            bar.style.height = '4px';
            waveformContainer.appendChild(bar);
            bars.push(bar);
        }

        // Audio context and analyzer
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let animationId = null;
        let stream = null;
        let currentState = 'idle';

        function setState(state) {
            if (state === currentState) return;
            currentState = state;

            console.log('[FloatingWindow] Setting state:', state);

            const pill = document.getElementById('pill');
            const indicator = document.getElementById('status-indicator');

            pill.className = 'pill state-' + state;

            document.getElementById('idle-text').classList.toggle('hidden', state !== 'idle');
            document.getElementById('recording-text').classList.toggle('hidden', state !== 'recording');
            document.getElementById('processing-text').classList.toggle('hidden', state !== 'processing');

            if (state === 'idle') {
                indicator.className = 'status-indicator idle';
                stopVisualization();
            } else if (state === 'recording') {
                indicator.className = 'status-indicator';
                startVisualization();
            } else if (state === 'processing') {
                indicator.className = 'status-indicator processing';
                stopVisualization();
            }
        }

        async function startVisualization() {
            if (stream) return; // Already running

            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);

                analyser.fftSize = 64;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                animate();
            } catch (error) {
                console.error('Failed to start visualization:', error);
            }
        }

        function animate() {
            if (!analyser) return;

            animationId = requestAnimationFrame(animate);
            analyser.getByteFrequencyData(dataArray);

            for (let i = 0; i < NUM_BARS; i++) {
                const dataIndex = Math.floor(i * dataArray.length / NUM_BARS);
                const value = dataArray[dataIndex] || 0;
                const height = Math.max(4, (value / 255) * 24);
                bars[i].style.height = height + 'px';
            }
        }

        function stopVisualization() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            analyser = null;

            // Reset bars
            bars.forEach(bar => bar.style.height = '4px');
        }

        // Listen for events from main app via postMessage
        window.addEventListener('message', function(event) {
            const { type, state } = event.data || {};

            if (type === 'setState') {
                setState(state);
            }
        });

        // Track if listeners are already set up
        let listenersSetup = false;

        // Setup Native event listeners
        function setupNativeListeners() {
            if (listenersSetup) {
                console.log('[FloatingWindow] Listeners already setup, skipping');
                return;
            }

            if (window.Native) {
                console.log('[FloatingWindow] Native available, setting up listeners');
                listenersSetup = true;

                // Listen for FloatingWindowState event
                Native.on('App\\Events\\FloatingWindowState', function(payload, event) {
                    console.log('[FloatingWindow] Received FloatingWindowState event:', payload);
                    if (payload && payload.state) {
                        setState(payload.state);
                    }
                });

                console.log('[FloatingWindow] Listeners registered successfully');
            } else {
                console.log('[FloatingWindow] Native not available yet');
            }
        }

        // Primary method: Listen for native:init event (per NativePHP docs)
        window.addEventListener('native:init', function() {
            console.log('[FloatingWindow] native:init event received');
            setupNativeListeners();
        });

        // Fallback: Check for Native every 500ms for up to 5 seconds
        let nativeCheckCount = 0;
        const nativeCheckInterval = setInterval(function() {
            nativeCheckCount++;
            if (window.Native && !listenersSetup) {
                setupNativeListeners();
                clearInterval(nativeCheckInterval);
            } else if (listenersSetup || nativeCheckCount >= 10) {
                clearInterval(nativeCheckInterval);
                if (!listenersSetup) {
                    console.log('[FloatingWindow] Native not available, using polling only');
                }
            }
        }, 500);

        // Polling fallback - always poll as events may not work reliably
        let pollingInterval = null;
        function startPolling() {
            if (pollingInterval) return;
            console.log('[FloatingWindow] Starting state polling');
            pollingInterval = setInterval(async function() {
                try {
                    const response = await fetch('/api/recording-state');
                    const data = await response.json();
                    if (data.state && data.state !== currentState) {
                        console.log('[FloatingWindow] State changed via poll:', data.state);
                        setState(data.state);
                    }
                } catch (e) {
                    // Ignore fetch errors
                }
            }, 200); // Poll every 200ms for responsive UI
        }

        // Initial state
        setState('idle');

        // Start polling after short delay (most reliable method)
        setTimeout(startPolling, 1000);

        // Window positioning is handled by PHP at boot time
    </script>
</body>
</html>
